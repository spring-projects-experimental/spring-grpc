[[client]]
= GRPC Client

This section describes core concepts that Spring gRPC uses on the client side.

== Create a `Channel`

You can inject a `GrpcChannelFactory` into your application configuration and use it to create a gRPC channel.
The most common usage of a channel is to create a client that binds to a service.
The Protobuf-generated sources in your project will contain the stub classes, and they just need to be bound to a channel.
The Protobuf files will be provided by the service you are connecting to.
For example, consider the `SimpleGrpc` service generated by the Protobuf tooling in your build.
To bind to this service on a local server:

[source,java]
----
@Bean
SimpleGrpc.SimpleBlockingStub stub(GrpcChannelFactory channels) {
	return SimpleGrpc.newBlockingStub(channels.createChannel("0.0.0.0:9090").build());
}
----

The `GrpcChannelFactory` creates a `ChannelBuilder` that you can customize before building the channel if necessary.

=== Shaded Netty Client

The default client implementation uses the Netty client.
You can switch to a shaded Netty implementation provided by the gRPC team by adding the `grpc-netty-shaded` dependency and excluding the `grpc-netty` dependency.

[source,xml]
----
<dependency>
	<groupId>org.springframework.grpc</groupId>
	<artifactId>spring-grpc-spring-boot-starter</artifactId>
	<exclusions>
		<exclusion>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-netty</artifactId>
		</exclusion>
	</exclusions>
</dependency>
<dependency>
	<groupId>io.grpc</groupId>
	<artifactId>grpc-netty-shaded</artifactId>
</dependency>
----

For Gradle users

[source,gradle]
----
dependencies {
	implementation "org.springframework.grpc:spring-grpc-spring-boot-starter"
	implementation 'io.grpc:grpc-netty-shaded'
	modules {
		module("io.grpc:grpc-netty") {
			replacedBy("io.grpc:grpc-netty-shaded", "Use Netty shaded instead of regular Netty")
		}
	}
}
----

== Channel Configuration

The default `GrpcChannelFactory` implementation can also create a "named" channel, which you can then use to extract the configuration to connect to the server.
For example:

[source,java]
----
@Bean
SimpleGrpc.SimpleBlockingStub stub(GrpcChannelFactory channels) {
	return SimpleGrpc.newBlockingStub(channels.createChannel("local").build());
}
----

then in `application.properties`:

[source,properties]
----
spring.grpc.client.channels.local.address=0.0.0.0:9090
----

There is a default named channel that you can configure as `spring.grpc.client.default-channel.*`, and then it will be used by default if there is no channel with the name specified in the channel creation.

Beans of type `GrpcChannelBuilderCustomizer` can be used to customize the `ChannelBuilder` before the channel is built.
This can be useful for setting up security, for example.

== The Local Server Port

If you are running a gRPC server locally as part of your application, you will often want to connect to it in an integration test.
It can be convenient in that case to use an ephemeral port for the server (`spring.grpc.server.port=0`) and then use the port that is allocated to connect to it.
You can discover the port that the server is running on by injecting the `@LocalGrpcPort` bean into your test.
The `@Bean` has to be marked as `@Lazy` to ensure that the port is available when the bean is created (it is only known when the server starts which is part of the startup process).

[source,java]
----
@Bean
@Lazy
SimpleGrpc.SimpleBlockingStub stub(GrpcChannelFactory channels, @LocalGrpcPort int port) {
	return SimpleGrpc.newBlockingStub(channels.createChannel("0.0.0.0:" + port).build());
}
----

[[client-interceptor]]
== Client Interceptors

=== Global
To add a client interceptor to be applied to all created channels you can simply register a client interceptor bean and then annotate it with `@GlobalClientInterceptor`.
The interceptors are ordered according to their bean natural ordering (i.e. `@Order`).

[source,java]
----
@Bean
@Order(100)
@GlobalClientInterceptor
ClientInterceptor myGlobalLoggingInterceptor() {
    return new MyLoggingInterceptor();
}
----

=== Per-Channel
To add one or more client interceptors to be applied to a single client channel you can simply pass in the interceptor instance(s) when invoking the channel factory to create the channel.

The interceptors are ordered according to their position in the specified list.

=== Blended
When a channel is constructed with both global and per-client interceptors, the global interceptors are first applied in their sorted order followed by the per-service interceptors in their sorted order.

However, by setting the `mergeWithGlobalInterceptors` parameter on the channel factory to `"true"` you can change this behavior so that the interceptors are all combined and then sorted according to their bean natural ordering (i.e. `@Order` or `Ordered` interface).

You can use this option if you want to add a per-client interceptor between global interceptors.

IMPORTANT: The per-channel interceptors you pass in must either be bean instances marked with `@Order` or regular objects that implement the `Ordered` interface to be properly merged/ordered with the global interceptors.

== Observability

Spring gRPC provides an autoconfigured interceptor that can be used to provide observability to your gRPC services.
All you need to do is add Spring Boot actuators to your project, and optionally a bridge to your observability platform of choice (just like https://docs.spring.io/spring-boot/reference/actuator/observability.html[any other Spring Boot application]).
